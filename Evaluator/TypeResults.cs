using System;
using System.CodeDom.Compiler;

namespace Evaluator
{
	/// <summary>
	/// Wraps the results of a programmatically-accessed compilation of a <see cref="Type"/> with the warnings generated by the compiler.
	/// </summary>
	public class TypeResults
	{
		Type type;
		AssemblyResults assemblyResults;

		/// <summary>
		/// Gets a specific method of the current <see cref="Type"/>.
		/// </summary>
		/// <param name="name">
		/// The name of the public method to get. 
		/// </param>
		/// <returns>
		/// A <see cref="MethodResults"/> object that wraps the specified method with the warnings generated by the compiler.
		/// </returns>
		public MethodResults GetMethod(string name)
		{
			return new MethodResults(type.GetMethod(name), this);
		}

		/// <summary>
		/// Gets a specific method of the current <see cref="Type"/>.
		/// </summary>
		/// <param name="name">
		/// The name of the public method to get. 
		/// </param>
		/// <param name="paramTypes">
		/// An array of <see cref="Type"/> objects representing the number, order, and type of the parameters for the method to get.
		/// <br/>
		/// <br/>
		/// -or- 
		/// <br/>
		/// <br/>
		/// An empty array of the type <see cref="Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.
		/// </param>
		/// <returns>
		/// A <see cref="MethodResults"/> object that wraps the specified method with the warnings generated by the compiler.
		/// </returns>
		public MethodResults GetMethod(string name, params Type[] paramTypes)
		{
			return new MethodResults(type.GetMethod(name, paramTypes), this);
		}

		/// <summary>
		/// Creates an instance of the <see cref="Type"/> represented by the current <see cref="TypeResults"/> object.
		/// </summary>
		/// <param name="parameters">
		/// The parameters to pass to the type's constructor.
		/// </param>
		/// <returns>
		/// An instance of the <see cref="Type"/> represented by the current <see cref="TypeResults"/> object.
		/// </returns>
		public object Instantiate(params object[] parameters)
		{
			return Activator.CreateInstance(type, parameters);
		}

		/// <summary>
		/// The collection of warnings generated by the compiler.
		/// </summary>
		public CompilerErrorCollection Warnings
		{
			get
			{
				return assemblyResults.Warnings;
			}
		}

		/// <summary>
		/// The final <see cref="Type"/> produced by the compiler.
		/// </summary>
		public Type Type
		{
			get
			{
				return type;
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TypeResults"/> class.
		/// </summary>
		/// <param name="typeReference">
		/// The final <see cref="Type"/> produced by the compiler.
		/// </param>
		/// <param name="compiledAssembly">
		/// The results of the programmatically-accessed compilation of the containing assembly.
		/// </param>
		protected internal TypeResults(Type typeReference, AssemblyResults compiledAssembly)
		{
			type = typeReference;
			assemblyResults = compiledAssembly;
		}
	}
}
